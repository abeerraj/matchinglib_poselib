# SemiRealSequence: Unlimited Semi-Real-World GT Data Generation Framework for Feature-Based Applications

- [Introduction](#introduction)
- [Different Scene Properties](#scene-properties)
- [Installation](#installation)
    - [Dependencies](#dependencies)
        - [Docker](#docker)
        - [System-wide Installation on Linux Systems](#system-dependencies)
    - [Data Generation using a Stand-Alone Executable](#executable)
    - [Executable for Annotating GTM and Datasets](#annotation)
    - [Library](#library)
- [Quick Start: Configuration File](#config-file)
- [Image Folder Structure](#image-folder)
    - [Oxford](#oxford)
    - [KITTI](#kitti)
    - [MegaDepth](#megadepth)
- [Reading Generated Data](#read-data)
- [Calculation of Ground Truth Matches and GT Optical Flow](#calculate-gtm)
- [Bulk Configuration File Generation](#multiple-config-files)
- [Random Testing and Data Generation](#random-test)
- [Publication](#publication)

## Introduction

Ground truth (GT) data is essential for testing and training computer vision applications.
For this purpose, many real-world and synthetic datasets emerged in recent years. 
Synthetic data provides perfect ground truth, which is hard to obtain for real-world data, but it lacks a realistic representation of the world. 
This framework combines the best properties of both worlds, which allows us to generate potentially limitless yet realistic GT data for testing and training feature-based applications. 
The framework generates synthetic semi-random **3D point clouds, stereo camera poses, and camera trajectories** according to given user requirements while using **real images** for generating sparse feature matches.
The latter are either generated by warping image patches or by utilizing GT matches from well-known datasets.
Homographies for warping image patches are calculated depending on generated 3D data to simulate piece-wise planar 3D structures.
The framework also enables the independent calculation of ground truth matches of various feature types from datasets providing GT flow, disparity, or depth information.
Functionality to calculate GT flow maps from mono depth data and a tool for annotating matches and used datasets is also included.

This repository includes a [library for integrating the framework](#library) into your own application as well as a [stand-alone executable](#executable) to generate data based on configuration files.

Generated data is stored in YAML or XML format which can be specified by the user.
For easy data interfacing, we provide a [C++ and Python interface](#read-data).

The software is tested on Ubuntu 18.04 but we provide a Docker-file for operating system independent usage.

## Different Scene Properties

SemiRealSequence supports to specify different scene and camera pose pose properties:
* Virtual image size
* Stereo poses:
    * Specific and/or variation of values or intervals for 6DOF relative poses (i.e. rotation angles and translation)
    * Number of different poses within a generated sequence (corresponds to a set of multiple stereo frames and a 3D point cloud)
    * Type (continuous or volatile) and amount of change for every pose parameter
    * Desired average image overlap of stereo cameras
* Camera trajectories:
    * A specific trajectory providing node coordinates,
    * a flag for utilizing a random trajectory optionally specifying a main direction, or
    * a function (currently only ellipsoids) can be provided.
* Static 3D point clouds and geometric matches:
    * A desired inlier ratio or interval
    * a relative inlier ratio variation rate
    * number or interval of true positive (TP) stereo correspondences
    * a relative variation rate for number of TP
    * a minimum distance between correspondences in the first stereo image
    * global depth ratios with respect to stereo cameras

Most parameters can be initialized randomly.

## Installation

We provide multiple possibilities to use this software:
* Stand-alone executables for 
    * generating semi-real-world stereo sequences based on configuration files, 
    * calculation of Ground Truth Matches (GTM) for datasets [Oxford](http://www.robots.ox.ac.uk/~vgg/research/affine/), [KITTI](http://www.cvlibs.net/datasets/kitti/eval_stereo_flow.php), and [MegaDepth](https://research.cs.cornell.edu/megadepth/), in addition to optical flow for the MegaDepth dataset, and for
    * annotating GTM and mentioned datasets.
* Docker for afore mentioned executables
* A library for generating semi-real-world stereo sequences that can be integrated into your own application

### Dependencies

#### Docker

For generating semi-real-world sequences using a stand-alone executable, [Docker](https://docs.docker.com/get-docker/) can be used.
After installing Docker, the corresponding Docker image can be built executing `./build_docker_base.sh` in the main directory of this repository.
On Windows, the image can be built by executing `docker build -t SemiRealSequence:1.0 .` in the main directory of this repository using Powershell.

#### System-wide Installation on Linux Systems

SemiRealSequence depends on the following libraries:
* Python 3.6.10
* Eigen 3.3.7
* Boost 1.71.0
* VTK 8.2.0
* PCL 1.11.0
* Ceres 1.14.0
* OpenCV 4.2.0

For installing above libraries, the following packages should be installed:
```bash
sudo apt-get update
sudo apt-get install software-properties-common apt-utils curl
Optional: curl https://pyenv.run | bash
Optional: env PYTHON_CONFIGURE_OPTS="--enable-shared" pyenv install -v 3.6.10 && pyenv global 3.6.10
sudo apt-get install libreadline-dev libglib2.0-dev
sudo add-apt-repository 'deb http://security.ubuntu.com/ubuntu xenial-security main'
sudo apt-get update
sudo apt-get install build-essential cmake pkg-config
sudo apt-get install wget \
    libtbb2 \
    libtbb-dev \
    libglew-dev \
    qt5-default \
    libxkbcommon-dev \
    libflann-dev \
    libpng-dev \
    libgtk-3-dev \
    libgtkglext1 \
    libgtkglext1-dev \
    libtiff-dev \
    libtiff5-dev \
    libtiffxx5 \
    libjpeg-dev \
    libjasper1 \
    libjasper-dev \
    libavcodec-dev \
    libavformat-dev \
    libswscale-dev \
    libv4l-dev \
    libxvidcore-dev \
    libx264-dev \
    libdc1394-22-dev \
    openexr \
    libatlas-base-dev \
    gfortran
sudo apt-get install libglu1-mesa-dev mesa-common-dev mesa-utils freeglut3-dev qt5-default
sudo apt-get install libgoogle-glog-dev \
    libatlas-base-dev \
    libsuitesparse-dev \
    libomp-dev \
    libhdf5-dev \
    libhdf5-serial-dev \
    libgstreamer-plugins-base1.0-dev \
    libgstreamer1.0-dev \
    libmpc-dev
```
All mentioned libries (Boost,  OpenCV, ...) can be installed by executing `./build_thirdparty.sh` within directory `ci` of this repository.
If some of the libraries are already installed on your system, missing libraries can be installed using the corresponding script file within directory `ci`.

In addition, needed Python packages can be installed by executing
```bash
python -m pip install --upgrade pip setuptools wheel
python -m pip install -r ./py_test_scripts/requirements.txt
```

### Data Generation using a Stand-Alone Executable

If not using Docker, SemiRealSequence can be built by executing `./build_SemiRealSequence.sh`.
The executables can be found in directory `generateVirtualSequence/build`

### Executable for Annotating GTM and Datasets

If you do NOT want to generate semi-real-world sequences but use the integrated annotation framework to generate GTM and annotation data, the follwing steps should be performed:
```bash
cd generateVirtualSequence
mkdir build
cd build
cmake ../ -DCMAKE_BUILD_TYPE=Release -DUSE_MANUAL_ANNOTATION=ON
make -j "$(nproc)"
```
For annotating data use executable `virtualSequenceLib-GTM-interface` within directory `generateVirtualSequence/build`.

### Library

To use SemiRealSequence within your own application, it can be built and installed performing the following steps:
```bash
cd generateVirtualSequence
mkdir build
cd build
cmake ../ -DCMAKE_BUILD_TYPE=Release
make -j "$(nproc)"
sudo make install
```

##Quick Start: Configuration File

If [Docker](#docker) or [stand-alone executables](#executable) are used, a template configuration file can be generated by either executing `./run_docker_base.sh live --genConfTempl /app/config/file` or `./generateVirtualSequence/build/virtualSequenceLib-CMD-interface --genConfTempl path/file`.
`path` stands for the full path and `file` for the filename that should be used for the configuration file.
The filename extension can either be `.yaml` or `.xml` to generate a template file in XML or YAML format.
For Docker, the generated configuration file can be found in folder `config` of the repository.

This file can either be used directly to generate data, or parameters can be adapted within the file.
A description of every parameter can be found in the file.

Before data can be generated, images and/or datasets must be accessible in one folder.
See [Image Folder Structure](#image-folder) for details.

To start generating a sequence execute `./run_docker_base.sh live --conf_file /app/config/file --img_path /app/images --img_pref / --store_path /app/data` or `./generateVirtualSequence/build/virtualSequenceLib-CMD-interface --conf_file path/file --img_path path_to_images --img_pref / --store_path output_path`.

## Image Folder Structure

For generating feature matches, images and/or datasets ([KITTI](http://www.cvlibs.net/datasets/kitti/eval_stereo_flow.php) and/or [MegaDepth](https://research.cs.cornell.edu/megadepth/)) must be present in one folder.
Images of any kind can be used (no need of corresponding GT data).
When executing SemiRealSequence, images can be filtered using option `--img_pref` by specifying sub-folders, pre- and/or and post-fixes.
For details call `./run_docker_base.sh live -h` or `./generateVirtualSequence/build/virtualSequenceLib-CMD-interface -h`.

If GTM from datasets KITTI (flow and disparity of years 2012 and 2015) and/or MegaDepth should be used, the datasets must be manually downloaded and copied into the image directory.

### Oxford

The [Oxford dataset](http://www.robots.ox.ac.uk/~vgg/research/affine/) is automatically downloaded and extracted as soon as parameter `oxfordGTMportion: >0` is specified in the configuration file.

### KITTI

Datasets from both years, [2012](http://www.cvlibs.net/download.php?file=data_stereo_flow.zip) and [2015](http://www.cvlibs.net/download.php?file=data_scene_flow.zip) have to be downloaded.
Create a folder `KITTI` and 2 sub-folders named `2012` and `2015` in your image-directory:
```bash
cd your_image_directory
mkdir KITTI
cd KITTI
mkdir 2012
mkdir 2015
```
Copy the corresponding extracted training datasets into the created folders:
```bash
cd download_folder
unzip data_stereo_flow.zip -d data_stereo_flow
cd data_stereo_flow/training
cp -r * /your_image_directory/KITTI/2012
cd ../..
unzip data_scene_flow.zip -d data_scene_flow
cd data_scene_flow/training
cp -r * /your_image_directory/KITTI/2015
```

### MegaDepth

Download the [MegaDepth v1 Dataset](https://research.cs.cornell.edu/megadepth/dataset/Megadepth_v1/MegaDepth_v1.tar.gz) (199GB) and [MegaDepth v1 SfM models](https://research.cs.cornell.edu/megadepth/dataset/MegaDepth_SfM/MegaDepth_SfM_v1.tar.xz) (667GB).
Be aware that downloading might take days depending on your internet connection.

Create a folder `MegaDepth` and 2 sub-folders `MegaDepth_v1` and `SfM` in your image-directory:
```bash
cd your_image_directory
mkdir MegaDepth
cd MegaDepth
mkdir MegaDepth_v1
mkdir SfM
```
After extracting downloaded MegaDepth_v1 data, move all numbered folders (i.e. `0000` to `5018`) into folder `your_image_directory/MegaDepth/MegaDepth_v1`.
After extracting downloaded SfM data, move all numbered folders (i.e. `0000` to `5018`) into folder `your_image_directory/MegaDepth/SfM`.

cmake-init is a copy and paste template, that provides the following features:
 * Cross Platform
  * Windows
  * Linux
  * Mac
 * Libraries, Applications, Testing template
 * Documentation template
 * Installation, Packaging template
 * CMake find script template for defined libraries

The files of cmake-init are an instantiation of the templates containing:
  * Example app
  * Example lib
  * Example test
  * Example documentation
  * Example package

| Service | System | Compiler | Targets | Status |
| ------- | ------ | -------- | ------- | ------ |
| [Drone](https://drone.io/github.com/cginternals/cmake-init) | Ubuntu 12.04 | GCC 4.8 | all (no qt), test | [![Build Status](https://drone.io/github.com/cginternals/cmake-init/status.png)](https://drone.io/github.com/cginternals/cmake-init/latest) |
| Jenkins | Ubuntu 14.04 | GCC 4.7 | all, test | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-linux-gcc4.7)](http://jenkins.hpi3d.de/job/cmake-init-linux-gcc4.7)|
| Jenkins | Ubuntu 14.04 | GCC 4.8 | all, test | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-linux-gcc4.8)](http://jenkins.hpi3d.de/job/cmake-init-linux-gcc4.8)|
| Jenkins | Ubuntu 14.04 | GCC 4.9 | all, test | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-linux-gcc4.9)](http://jenkins.hpi3d.de/job/cmake-init-linux-gcc4.9)|
| Jenkins | Ubuntu 14.04 | GCC 5.3 | all, test | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-linux-gcc5.3)](http://jenkins.hpi3d.de/job/cmake-init-linux-gcc5.3)|
| Jenkins | Ubuntu 14.04 | Clang 3.5 | all, test | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-linux-clang3.5)](http://jenkins.hpi3d.de/job/cmake-init-linux-clang3.5) |
| Jenkins | OS X 10.10 | Clang 3.5 | - | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-osx-clang3.5)](http://jenkins.hpi3d.de/job/cmake-init-osx-clang3.5) |
| Jenkins | Windows 8.1 | MSVC 2013 Update 5 | all, test, install | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-windows-msvc2013)](http://jenkins.hpi3d.de/job/cmake-init-windows-msvc2013) |
| Jenkins | Windows 8.1 | MSVC 2015 Update 1 | all, test, install | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-windows-msvc2015)](http://jenkins.hpi3d.de/job/cmake-init-windows-msvc2015) |


## Design Decisions

ToDo: revisit!

#### Console vs. Windows App (Windows only)

decisions:
* we do not use the msvc subsystem linker flag
* we do not use the add_executable win32 property
* instead the ```set_target_properties``` with the ```WIN32_EXECUTABLE``` flag on target executable is used
* we use the same subsystem for all configurations of a single target (no switching between, e.g., debug and release)

rationale:
typically, only released 'feature' applications are required to decide on their subsystem, and in the case of 'gui-heavy' applications the windows subsystem is preferred (since the std output is probably piped into widgets, logfiles, or even discard).

furthermore, console output is usually more relevant for development/debugging purposes, already using console or IDE with appropriate console output handling



ToDo: Add missing content, bring into markdown form


Scenarios covered in cmake-init:


1) Development

The project is contained in a source directory for active development.

binaries: ./build
rpath:    absolute paths to all dependencies
datapath: ..


2) Installation (default)

The project is installed in a self-contained directory, ready for being moved or copied to another location or computer.

binaries: ./bin
rpath:    $ORIGIN/../lib
datapath: ..


3) Installation (unix system install)

The project is installed globally on a system.

binaries: /usr/[local/]bin
rpath:    empty
datapath: /usr/[local/]share/<projectname>

## Citation

Please cite the following paper if you use SemiRealSequence or parts of this code in your own work.

```
@inproceedings{maier2020semireal,
  title={Unlimited Semi-Real-World Ground Truth Generation for Feature-Based Applications},
  author={Maier, Josef},
  booktitle={ACCV},
  year={2020}
}
```
