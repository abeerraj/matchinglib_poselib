# SemiRealSequence: Unlimited Semi-Real-World GT Data Generation Framework for Feature-Based Applications

- [Introduction](#introduction)
- [Installation](#installation)
    - [Dependencies](#dependencies)
        - [Docker](#docker)
        - [System-wide installation on Linux systems](#system-dependencies)
    - [Data Generation using a Stand-Alone Executable](#executable)
    - [Executable for annotating GTM and datasets](#annotation)
    - [Library](#library)
- [Quick Start: Configuration File](#config-file)
- [Image Folder Structure](#image-folder)
- [Reading Generated Data](#read-data)
- [Calculation of Ground Truth Matches and GT Optical Flow](#calculate-gtm)
- [Bulk Configuration File Generation](#multiple-config-files)
- [Random Testing and Data Generation](#random-test)
- [Publication](#publication)

## Introduction

Ground truth (GT) data is essential for testing and training computer vision applications.
For this purpose, many real-world and synthetic datasets emerged in recent years. 
Synthetic data provides perfect ground truth, which is hard to obtain for real-world data, but it lacks a realistic representation of the world. 
This framework combines the best properties of both worlds, which allows us to generate potentially limitless yet realistic GT data for testing and training feature-based applications. 
The framework generates synthetic semi-random **3D point clouds, stereo camera poses, and camera trajectories** according to given user requirements while using **real images** for generating sparse feature matches.
The latter are either generated by warping image patches or by utilizing GT matches from well-known datasets.
Homographies for warping image patches are calculated depending on generated 3D data to simulate piece-wise planar 3D structures.
The framework also enables the independent calculation of ground truth matches of various feature types from datasets providing GT flow, disparity, or depth information.
Functionality to calculate GT flow maps from mono depth data and a tool for annotating matches and used datasets is also included.

This repository includes a [library for integrating the framework](#library) into your own application as well as a [stand-alone executable](#executable) to generate data based on configuration files.

Generated data is stored in YAML or XML format which can be specified by the user.
For easy data interfacing, we provide a [C++ and Python interface](#read-data).

The software is tested on Ubuntu 18.04 but we provide a Docker-file for operating system independent usage.

##Installation

We provide multiple possibilities to use this software:
* Stand-alone executables for 
    * generating semi-real-world stereo sequences based on configuration files, 
    * calculation of Ground Truth Matches (GTM) for datasets [Oxford](http://www.robots.ox.ac.uk/~vgg/research/affine/), [KITTI](http://www.cvlibs.net/datasets/kitti/eval_stereo_flow.php), and [MegaDepth](https://research.cs.cornell.edu/megadepth/), in addition to optical flow for the MegaDepth dataset, and for
    * annotating GTM and mentioned datasets.
* Docker for afore mentioned executables
* A library for generating semi-real-world stereo sequences that can be integrated into your own application

###Dependencies

####Docker

For generating semi-real-world sequences using a stand-alone executable, [Docker](https://docs.docker.com/get-docker/) can be used.
After installing Docker, the corresponding Docker image can be built executing `./build_docker_base.sh` in the main directory of this repository.
On Windows, the image can be built by executing `docker build -t SemiRealSequence:1.0 .` in the main directory of this repository using Powershell.

####System-wide installation on Linux systems

SemiRealSequence depends on the following libraries:
* Python 3.6.10
* Eigen 3.3.7
* Boost 1.71.0
* VTK 8.2.0
* PCL 1.11.0
* Ceres 1.14.0
* OpenCV 4.2.0

For installing above libraries, the following packages should be installed:
```bash
sudo apt-get update
sudo apt-get install software-properties-common apt-utils curl
Optional: curl https://pyenv.run | bash
Optional: env PYTHON_CONFIGURE_OPTS="--enable-shared" pyenv install -v 3.6.10 && pyenv global 3.6.10
sudo apt-get install libreadline-dev libglib2.0-dev
sudo add-apt-repository 'deb http://security.ubuntu.com/ubuntu xenial-security main'
sudo apt-get update
sudo apt-get install build-essential cmake pkg-config
sudo apt-get install wget \
    libtbb2 \
    libtbb-dev \
    libglew-dev \
    qt5-default \
    libxkbcommon-dev \
    libflann-dev \
    libpng-dev \
    libgtk-3-dev \
    libgtkglext1 \
    libgtkglext1-dev \
    libtiff-dev \
    libtiff5-dev \
    libtiffxx5 \
    libjpeg-dev \
    libjasper1 \
    libjasper-dev \
    libavcodec-dev \
    libavformat-dev \
    libswscale-dev \
    libv4l-dev \
    libxvidcore-dev \
    libx264-dev \
    libdc1394-22-dev \
    openexr \
    libatlas-base-dev \
    gfortran
sudo apt-get install libglu1-mesa-dev mesa-common-dev mesa-utils freeglut3-dev qt5-default
sudo apt-get install libgoogle-glog-dev \
    libatlas-base-dev \
    libsuitesparse-dev \
    libomp-dev \
    libhdf5-dev \
    libhdf5-serial-dev \
    libgstreamer-plugins-base1.0-dev \
    libgstreamer1.0-dev \
    libmpc-dev
```
All mentioned libries (Boost,  OpenCV, ...) can be installed by executing `./build_thirdparty.sh` within directory `ci` of this repository.
If some of the libraries are already installed on your system, missing libraries can be installed using the corresponding script file within directory `ci`.

In addition, needed Python packages can be installed by executing
```bash
python -m pip install --upgrade pip setuptools wheel
python -m pip install -r ./py_test_scripts/requirements.txt
```

###Data Generation using a Stand-Alone Executable

If not using Docker, SemiRealSequence can be built by executing `./build_SemiRealSequence.sh`.
The executables can be found in directory `generateVirtualSequence/build`

###Executable for annotating GTM and datasets

If you do NOT want to generate semi-real-world sequences but use the integrated annotation framework to generate GTM and annotation data, the follwing steps should be performed:
```bash
cd generateVirtualSequence
mkdir build
cd build
cmake ../ -DCMAKE_BUILD_TYPE=Release -DUSE_MANUAL_ANNOTATION=ON
make -j "$(nproc)"
```
For annotating data use executable `virtualSequenceLib-GTM-interface` within directory `generateVirtualSequence/build`.

###Library

To use SemiRealSequence within your own application, it can be built and installed performing the following steps:
```bash
cd generateVirtualSequence
mkdir build
cd build
cmake ../ -DCMAKE_BUILD_TYPE=Release
make -j "$(nproc)"
sudo make install
```

##Quick Start: Configuration File

If [Docker](#docker) or [stand-alone executables](#executable) are available, a template configuration file can be generated by either executing `./run_docker_base.sh live --genConfTempl /app/data/file` or `./generateVirtualSequence/build/virtualSequenceLib-CMD-interface --genConfTempl path/file`.
`path` stands for the full path and `file` for the filename that should be used for the configuration file.
The filename extension can either be `.yaml` or `.xml` to generate a template file in XML or YAML format.
For Docker, the generated configuration file can be found in folder `data` of the repository.

This file can either be used directly to generate data, or parameters can be adapted within the file.
A description of every parameter can be found in the file.


cmake-init is a copy and paste template, that provides the following features:
 * Cross Platform
  * Windows
  * Linux
  * Mac
 * Libraries, Applications, Testing template
 * Documentation template
 * Installation, Packaging template
 * CMake find script template for defined libraries

The files of cmake-init are an instantiation of the templates containing:
  * Example app
  * Example lib
  * Example test
  * Example documentation
  * Example package

| Service | System | Compiler | Targets | Status |
| ------- | ------ | -------- | ------- | ------ |
| [Drone](https://drone.io/github.com/cginternals/cmake-init) | Ubuntu 12.04 | GCC 4.8 | all (no qt), test | [![Build Status](https://drone.io/github.com/cginternals/cmake-init/status.png)](https://drone.io/github.com/cginternals/cmake-init/latest) |
| Jenkins | Ubuntu 14.04 | GCC 4.7 | all, test | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-linux-gcc4.7)](http://jenkins.hpi3d.de/job/cmake-init-linux-gcc4.7)|
| Jenkins | Ubuntu 14.04 | GCC 4.8 | all, test | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-linux-gcc4.8)](http://jenkins.hpi3d.de/job/cmake-init-linux-gcc4.8)|
| Jenkins | Ubuntu 14.04 | GCC 4.9 | all, test | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-linux-gcc4.9)](http://jenkins.hpi3d.de/job/cmake-init-linux-gcc4.9)|
| Jenkins | Ubuntu 14.04 | GCC 5.3 | all, test | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-linux-gcc5.3)](http://jenkins.hpi3d.de/job/cmake-init-linux-gcc5.3)|
| Jenkins | Ubuntu 14.04 | Clang 3.5 | all, test | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-linux-clang3.5)](http://jenkins.hpi3d.de/job/cmake-init-linux-clang3.5) |
| Jenkins | OS X 10.10 | Clang 3.5 | - | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-osx-clang3.5)](http://jenkins.hpi3d.de/job/cmake-init-osx-clang3.5) |
| Jenkins | Windows 8.1 | MSVC 2013 Update 5 | all, test, install | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-windows-msvc2013)](http://jenkins.hpi3d.de/job/cmake-init-windows-msvc2013) |
| Jenkins | Windows 8.1 | MSVC 2015 Update 1 | all, test, install | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-windows-msvc2015)](http://jenkins.hpi3d.de/job/cmake-init-windows-msvc2015) |


## Design Decisions

ToDo: revisit!

#### Console vs. Windows App (Windows only)

decisions:
* we do not use the msvc subsystem linker flag
* we do not use the add_executable win32 property
* instead the ```set_target_properties``` with the ```WIN32_EXECUTABLE``` flag on target executable is used
* we use the same subsystem for all configurations of a single target (no switching between, e.g., debug and release)

rationale:
typically, only released 'feature' applications are required to decide on their subsystem, and in the case of 'gui-heavy' applications the windows subsystem is preferred (since the std output is probably piped into widgets, logfiles, or even discard).

furthermore, console output is usually more relevant for development/debugging purposes, already using console or IDE with appropriate console output handling



ToDo: Add missing content, bring into markdown form


Scenarios covered in cmake-init:


1) Development

The project is contained in a source directory for active development.

binaries: ./build
rpath:    absolute paths to all dependencies
datapath: ..


2) Installation (default)

The project is installed in a self-contained directory, ready for being moved or copied to another location or computer.

binaries: ./bin
rpath:    $ORIGIN/../lib
datapath: ..


3) Installation (unix system install)

The project is installed globally on a system.

binaries: /usr/[local/]bin
rpath:    empty
datapath: /usr/[local/]share/<projectname>

## Citation

Please cite the following paper if you use SemiRealSequence or parts of this code in your own work.

```
@inproceedings{maier2020semireal,
  title={Unlimited Semi-Real-World Ground Truth Generation for Feature-Based Applications},
  author={Maier, Josef},
  booktitle={ACCV},
  year={2020}
}
```
