# SemiRealSequence: Unlimited Semi-Real-World GT Data Generation Framework for Feature-Based Applications

- [Introduction](#introduction)
- [Installation](#installation)
    - [Dependencies](#dependencies)
    - [Data Generation using a Stand-Alone Executable](#executable)
    - [Library](#library)
- [Quick Start: Configuration File](#config-file)
- [Image Folder Structure](#image-folder)
- [Reading Generated Data](#read-data)
- [Calculation of Ground Truth Matches and GT Optical Flow](#calculate-gtm)
- [Bulk Configuration File Generation](#multiple-config-files)
- [Random Testing and Data Generation](#random-test)
- [Publication](#publication)

## Introduction

Ground truth (GT) data is essential for testing and training computer vision applications.
For this purpose, many real-world and synthetic datasets emerged in recent years. 
Synthetic data provides perfect ground truth, which is hard to obtain for real-world data, but it lacks a realistic representation of the world. 
This framework combines the best properties of both worlds, which allows us to generate potentially limitless yet realistic GT data for testing and training feature-based applications. 
The framework generates synthetic semi-random **3D point clouds, stereo camera poses, and camera trajectories** according to given user requirements while using **real images** for generating sparse feature matches.
The latter are either generated by warping image patches or by utilizing GT matches from well-known datasets.
Homographies for warping image patches are calculated depending on generated 3D data to simulate piece-wise planar 3D structures.
The framework also enables the independent calculation of ground truth matches of various feature types from datasets providing GT flow, disparity, or depth information.
Functionality to calculate GT flow maps from mono depth data and a tool for annotating matches and used datasets is also included.

This repository includes a [library for integrating the framework](#library) into your own application as well as a [stand-alone executable](#executable) to generate data based on configuration files.

Generated data is stored in YAML or XML format which can be specified by the user.
For easy data interfacing, we provide a [C++ and Python interface](#read-data).

The software is tested on Ubuntu 18.04 but we provide a Docker-file for operating system independent usage.

cmake-init is a copy and paste template, that provides the following features:
 * Cross Platform
  * Windows
  * Linux
  * Mac
 * Libraries, Applications, Testing template
 * Documentation template
 * Installation, Packaging template
 * CMake find script template for defined libraries

The files of cmake-init are an instantiation of the templates containing:
  * Example app
  * Example lib
  * Example test
  * Example documentation
  * Example package

| Service | System | Compiler | Targets | Status |
| ------- | ------ | -------- | ------- | ------ |
| [Drone](https://drone.io/github.com/cginternals/cmake-init) | Ubuntu 12.04 | GCC 4.8 | all (no qt), test | [![Build Status](https://drone.io/github.com/cginternals/cmake-init/status.png)](https://drone.io/github.com/cginternals/cmake-init/latest) |
| Jenkins | Ubuntu 14.04 | GCC 4.7 | all, test | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-linux-gcc4.7)](http://jenkins.hpi3d.de/job/cmake-init-linux-gcc4.7)|
| Jenkins | Ubuntu 14.04 | GCC 4.8 | all, test | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-linux-gcc4.8)](http://jenkins.hpi3d.de/job/cmake-init-linux-gcc4.8)|
| Jenkins | Ubuntu 14.04 | GCC 4.9 | all, test | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-linux-gcc4.9)](http://jenkins.hpi3d.de/job/cmake-init-linux-gcc4.9)|
| Jenkins | Ubuntu 14.04 | GCC 5.3 | all, test | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-linux-gcc5.3)](http://jenkins.hpi3d.de/job/cmake-init-linux-gcc5.3)|
| Jenkins | Ubuntu 14.04 | Clang 3.5 | all, test | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-linux-clang3.5)](http://jenkins.hpi3d.de/job/cmake-init-linux-clang3.5) |
| Jenkins | OS X 10.10 | Clang 3.5 | - | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-osx-clang3.5)](http://jenkins.hpi3d.de/job/cmake-init-osx-clang3.5) |
| Jenkins | Windows 8.1 | MSVC 2013 Update 5 | all, test, install | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-windows-msvc2013)](http://jenkins.hpi3d.de/job/cmake-init-windows-msvc2013) |
| Jenkins | Windows 8.1 | MSVC 2015 Update 1 | all, test, install | [![Build Status](http://jenkins.hpi3d.de/buildStatus/icon?job=cmake-init-windows-msvc2015)](http://jenkins.hpi3d.de/job/cmake-init-windows-msvc2015) |


## Design Decisions

ToDo: revisit!

#### Console vs. Windows App (Windows only)

decisions:
* we do not use the msvc subsystem linker flag
* we do not use the add_executable win32 property
* instead the ```set_target_properties``` with the ```WIN32_EXECUTABLE``` flag on target executable is used
* we use the same subsystem for all configurations of a single target (no switching between, e.g., debug and release)

rationale:
typically, only released 'feature' applications are required to decide on their subsystem, and in the case of 'gui-heavy' applications the windows subsystem is preferred (since the std output is probably piped into widgets, logfiles, or even discard).

furthermore, console output is usually more relevant for development/debugging purposes, already using console or IDE with appropriate console output handling



ToDo: Add missing content, bring into markdown form


Scenarios covered in cmake-init:


1) Development

The project is contained in a source directory for active development.

binaries: ./build
rpath:    absolute paths to all dependencies
datapath: ..


2) Installation (default)

The project is installed in a self-contained directory, ready for being moved or copied to another location or computer.

binaries: ./bin
rpath:    $ORIGIN/../lib
datapath: ..


3) Installation (unix system install)

The project is installed globally on a system.

binaries: /usr/[local/]bin
rpath:    empty
datapath: /usr/[local/]share/<projectname>

## Citation

Please cite the following paper if you use SemiRealSequence or parts of this code in your own work.

```
@inproceedings{maier2020semireal,
  title={Unlimited Semi-Real-World Ground Truth Generation for Feature-Based Applications},
  author={Maier, Josef},
  booktitle={ACCV},
  year={2020}
}
```
